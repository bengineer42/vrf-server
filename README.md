## Run server

`cargo run`

## Get server's public key

`GET http://0.0.0.0:3000/info`

## Get random numbers

```js
const response = await fetch("http://0.0.0.0:3000/stark_vrf", {
  method: "POST",
  headers: {
    "Content-Type": "application/json",
  },
  body: JSON.stringify({
    seed: ["0x5733e5c2c8030bc06888747525b1a1f0242ca770c9387b58a4529df0ca55499"],
  }),
});
const json = await response.json();
```

which will return:

```js
{
    "result": {
        "gamma_x": "0x6ac32f9b3c0bef88e4e1ba77d2f77fa603bbd4b42cca6405c5bdf7a16821d75",
        "gamma_y": "0x50e3875635d84cb0038dbccb309b1134e101aee38c02001e456d5988b39fd43",
        "c": "0x111fd321fb9b48c651a871fcfeea71a0f521ba04fe54f81caf2f407cba0979f",
        "s": "0x437d280a8eb8e1e57c291af359738118c5b64b00ff5bd209d86ef83b051a2c6",
        "sqrt_ratio": "0xa99242633a4f2a7b31c4c7d3bee93dad3bd946a68cfac753dbd4bbd837d8c0",
        "rnd": "0x41c6b570b6720f205da6ef692021fe3625bbbab1ef5ea0ecea470e2d93b7982"
    }
}
```

# Contracts

## Verify proof in Cairo

See https://github.com/dojoengine/stark-vrf

## Deployed random contract

### Work flow

### [request_random](./contracts/src/vrf_provider/vrf_provider_component.cairo#156)

```rust
fn request_random(
        ref self: TContractState, consumer: ContractAddress, key: felt252, as_caller: bool,
    ) -> felt252
```

The arguments are:

- consumer: `ContractAddress` The contract that will consume the random
- key: `felt252` a key so multiple random calls can be done separately by the same contract (could be a hash of other data such as call data)
- as_caller: `bool` Whether the random is user specific or not

For each valid call to each `consumer, caller, key` a nonce is added so each seed is unique.

A RequestRandom event is then emitted which is the picked up on by the VRF server which then creates a proof to be submitted.

```rust
struct RequestRandom {
  consumer: ContractAddress,
  caller: ContractAddress,
  key: felt252,
  nonce: felt252,
  seed: felt252,
}
```

### [submit_random](./contracts/src/vrf_provider/vrf_provider_component.cairo#182)

```rust
fn submit_random(ref self: ComponentState<TContractState>, seed: felt252, proof: Proof);
```

bengineer42: make the readme secon for submit_random

GitHub Copilot: ### submit_random

```rust
fn submit_random(ref self: ComponentState<TContractState>, seed: felt252, proof: Proof);
```

The arguments are:

- seed: `felt252` The seed for which the random number is being submitted.
- proof: `Proof` The proof generated by the VRF server to verify the randomness.

This function is called by executors to submit the random number generated by the VRF server. The function performs the following steps:

1. **Check if the seed has already been submitted**: It asserts that the seed has not been submitted before using the `is_submitted` function.
2. **Verify the proof**: It verifies the proof using the public key and the [ECVRF implementation](https://github.com/dojoengine/stark-vrf).
3. **Write the random number**: It writes the random number to the storage.
4. **Emit the SubmitRandom event**: It emits the `SubmitRandom` event with the seed and proof.

The `SubmitRandom` event structure is as follows:

```rust
struct SubmitRandom {
    seed: felt252,
    proof: Proof,
}
```

### [consume_random](./contracts/src/vrf_provider/vrf_provider_component.cairo#200)

```rust
fn consume_random(ref self: ComponentState<TContractState>, caller: ContractAddress, key: felt252) -> felt252;
```

The arguments are:

- caller: `ContractAddress` The address of the contract that requested the random number.
- key: `felt252` A key to identify the specific random request.

This function is called by consumers to retrieve the random number associated with a given seed. The function performs the following steps:

1. **Check if the random has been submitted and not consumed**: It asserts that the seed has been submitted

2. **Return the random number**: It returns the fetched random number.

The function ensures that only previously submitted seeds can be used to retrieve random numbers, maintaining the integrity and reliability of the randomness provided.

## Retreaving the random

To make things as simple as possible only two calls are required to use the VRF

The caller requests random for the desired contract by calling the [request_random](#request_random) function with a key and as_caller.

the consumer conrtact consumes the random for the correct key and caller usign the [consume_random](#consume_random).
